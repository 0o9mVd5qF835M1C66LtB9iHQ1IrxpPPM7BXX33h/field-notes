built-ins
- built-in functions are *predeclared*
- the built-in functions do *not* have standard go types
- they can only appear in call expressions, *not* as function values

- close
    - the built-in function close records that no more values will be sent on the channel
    - it's an error if the channel is a receive-only channel
    - sending to or closing an already-closed channel causes a run-time panic
    - closing a nil channel also causes a run-time panic
    - after calling close, and after any previously sent values have been received, receive operations will return the zero value for the channel's type without blocking

- length and capacity
    - the built-in functions len and cap take arguments of various types
    - they both return a result of type int
    - the implementation guarantees that the resut always fits an int
    - the capacity of a slice is the number of elements for which there is space allocated in the underlying array
        - at any time the following relationship holds:
        0 <= len(s) <= cap(s)
    - the len of a nil slice, map, or channel is 0
    - the capacity of a nil slice or channel is 0

- allocation
    - the built-in function new takes a type T, allocates storage for a variable of that type at run time, and returns a value of type *T pointing to it


- making slices, maps, and channels
    - the built-in function make takes a type T, optionally followed by a type-specific list of expressions
        - slice: make(T, n, m)
        - map: make(T, n)
        - ch: make(T, n)
        - note that only slices support a capacity argument (i guess only slices have a dynamic resizing implementation underneath the hood?)

- slices
    - the built-in functions append and copy assist in common slice operations
    ```
    append(s S, x ...E) S // core type of S is []E
    copy(dst, src[]T) int
    ```

- map deletions
    - the built-in function delete removes the element with key k from a map m
    ```
    delete(m, k) // removes element m[k] from map m
    ```
    - if m is nil or m[k] dne, delete is a no-op
- complex numbers
    - three functins assemble and disassemble complex numbers
    ```
    complex(realPart, imaginaryPart floatT) complexT
    real(complexT) floatT
    imag(complexT) floatT
    ```
- handling panics
    - two built-ins, panic and recover, assist in reporting and handling run-time panics and program-defined error conditions
    ```
    func panic(interface{})
    func recover() interface{}
    ```
    - notes from jeff
        - panics are glorified gotos
        - the caller of the function panicking has no control over execution
        - library code could should never panic, or at least never let panics escape program code
        - application code is ok to panic, in scenarios where the program should just quit
    ```
        func f() {
            defer func() {
                if x := recover(); x != nil {
                    log.Println("run time panic: %v", x)
                }
            }()

            g() // panics
        }
    ```


packages
- go programs are constructed by linking packages together
    - in turn, a package is constructed from one or more source files
        - these source files declare constants, types, variables, and functions
        - the elements above are accessible in all files of the same package
        - these elements may be exported and used in another package
- source file organization
    ```
    SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
    ```

- package clause
    ```
    PackageClause = "package" PackageName .
    PackageName = identifer. // must not be blank
    ```
        
    - a set of files sharing the same package name form the *implementation* of the package

- import declarations
    - an import declaration states that the source file containing the declaration depends on functionality of the imported package
    - the declaration eables access to *exported* identifiers of that package
    - an import declaration declares a dependency relation between the importing and imported package
        - it's illegal for a package to import itself, directly or indirectly
        - it's also illegal to import a package without referring to any of its exported identifiers
        - to import a packafge solely for its side-effects (initialiation) use the black identifier as explicit package name
        ```
        import _ "lib/math" // just like unused variables
        ```
        - the interpretation of the import path is implementation-dependant but it is typically a substring of the full fil name of the compiled package
        ```
        import "lib/math"    math.Sin
        import m "lib/math"  m.Sin
        import . "lib/math"  Sin
        ```

program initialization and execution

errors & run-time panics
- the `error` type is defined as
    ```
    type error interface {
        Error() string
    }
    ```
- execution errors such as out-of-bounds array indexing triggers a run-time panic, which is a built-in function panic with a value of the implementation-defined runtime.
    - that type satisfies the predclared interface type `error`
    - the exact error values that represent distinct run-time error conditions are unspecified
    ```
    package runtime

    type Error interface {
        error
        // and perhaps other methods
    }
    ```

system considerations
- package unsafe
    - the unsafe package provides low-level programming operations that violate the type system
        - golang restricts pointer operations
        - there is no linguistic mechanism to convert between pointers and integers
        - the package unsafe implements this functionality under restricted circumstances
    - a package using unsafe must be vetted manually for type safety and may *not* be portable
        the results of functions from unsafe are consistent in the same program, but they might differ when crossing operating systems, architectures, compilers, compiler versions, etc
    - a package using unsafe is not protected by the Go 1 compatability guidelines
    - func Alignof(x ArbitraryType) uintptr
    - func Offsetof(x ArbitraryType) uintptr
    - func Sizeof(x ArbitraryType) uintptr
    - type Pointer *ArbitraryType
        - equivalent of C's void*


- size and alignmenet guarantees
    - for numeric types, the following sizes in bytes are guaranteed
        byte, uint8, int8                     1 (8 bits)
        uint16, int16                         2 (16 bits)
        uint32, int32, float32                4 (32 bits)
        uint64, int64, float64, complex64     8 (64 bits)
        complex128                           16 (128 bits)
    - a struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero
    - two distinct zero-size variables may have the same address in memory!